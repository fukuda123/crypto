#!/usr/bin/python3
# -*- coding: utf-8 -*-

# ----------------------------------------------------------
# 【概要】
# SHE規格のCMD_LOAD_KEYで用いるM1〜M5を生成します。
#
# 【必要ソフト】
# Python3, PyCryptodome
#
# 【使い方】
# 以下の変数の値を変更し、本スクリプトを実行します。
# 変数はすべて16進文字列です。
#   key_new
#   key_authid
#   uid
#   kid
#   authid
#   c_id
#   f_id
#
# 【参考元】
# https://www.autosar.org/fileadmin/user_upload/standards/foundation/19-11/AUTOSAR_TR_SecureHardwareExtensions.pdf
# タイトル：Specification of Secure Hardware Extensions
# バージョン：R19-11
# 発行日：2019-11-28
# アクセス日：2021-10-23
# ----------------------------------------------------------

# ----------------------------------------------------------
# 新しい鍵の値（KEY_NEW）
# ----------------------------------------------------------
key_new = "0f0e0d0c0b0a09080706050403020100"

# ----------------------------------------------------------
# KEY_NEWを暗号化・検証するための鍵の値（KEY_AuthID）
# ----------------------------------------------------------
key_authid = "000102030405060708090a0b0c0d0e0f"

# ----------------------------------------------------------
# ユニークID（UID）
# ----------------------------------------------------------
uid = "000000000000000000000000000001"

# ----------------------------------------------------------
# 更新対象の鍵のID
# ----------------------------------------------------------
kid = "4"

# ----------------------------------------------------------
# KEY_NEWを暗号化・検証するための鍵のID（AuthID）
# ----------------------------------------------------------
authid = "1"

# ----------------------------------------------------------
# カウンタ（C_ID）
# ----------------------------------------------------------
c_id = "0000001"

# ----------------------------------------------------------
# フラグ（F_ID）
#   Bit 4: WRITE_PROTECTION
#   Bit 3: BOOT_PROTECTION
#   Bit 2: DEBUGGER_PROTECTION
#   Bit 1: KEY_USAGE
#   Bit 0: WILDCARD
# ----------------------------------------------------------
f_id = "00"

# ----------------------------------------------------------
# 以上がユーザ変数。
# ここ以降は処理なので変更不要。
# ----------------------------------------------------------

import sys
import binascii
import Crypto.Cipher.AES
import Crypto.Hash.CMAC

# ----------------------------------------------------------
# 【定数】KEY_UPDATE_ENC_C
# ----------------------------------------------------------
key_update_enc_c = "010153484500800000000000000000B0"

# ----------------------------------------------------------
# 【定数】KEY_UPDATE_MAC_C
# ----------------------------------------------------------
key_update_mac_c = "010253484500800000000000000000B0"

# ----------------------------------------------------------
# 【関数】16進文字列かどうかの判定関数。ビット長もチェック。
# ----------------------------------------------------------
def is_hex(val_str, exp_bitlen):
    try:
        if (type(val_str) is not str):
            return False
        if (len(val_str) != ((exp_bitlen + 3) // 4)):
            return False
        val_int = int(val_str, 16)
        if ((val_int < 0) or (val_int >= (2 ** exp_bitlen))):
            return False
        return True
    except:
        return False

# ----------------------------------------------------------
# 【処理】パラメータのビット長をチェック。
# ----------------------------------------------------------
if not is_hex(key_new, 128):
    print("[ERROR] key_new is invalid.")
    sys.exit(0)
if not is_hex(key_authid, 128):
    print("[ERROR] key_authid is invalid.")
    sys.exit(0)
if not is_hex(uid, 120):
    print("[ERROR] uid is invalid.")
    sys.exit(0)
if not is_hex(kid, 4):
    print("[ERROR] uid is invalid.")
    sys.exit(0)
if not is_hex(authid, 4):
    print("[ERROR] uid is invalid.")
    sys.exit(0)
if not is_hex(c_id, 28):
    print("[ERROR] c_id is invalid.")
    sys.exit(0)
if not is_hex(f_id, 5):
    print("[ERROR] f_id is invalid.")
    sys.exit(0)

# ----------------------------------------------------------
# 【関数】AES-ECBの暗号化。
# ----------------------------------------------------------
def enc_aes_ecb(pt, key):
    pt_binstr = binascii.unhexlify(pt)
    key_binstr = binascii.unhexlify(key)
    cipher = Crypto.Cipher.AES.new(key_binstr, Crypto.Cipher.AES.MODE_ECB)
    return cipher.encrypt(pt_binstr).hex()

# ----------------------------------------------------------
# 【関数】AES-CBCの暗号化。
# ----------------------------------------------------------
def enc_aes_cbc(pt, key, iv):
    pt_binstr = binascii.unhexlify(pt)
    key_binstr = binascii.unhexlify(key)
    iv_binstr = binascii.unhexlify(iv)
    cipher = Crypto.Cipher.AES.new(key_binstr, Crypto.Cipher.AES.MODE_CBC, iv_binstr)
    return cipher.encrypt(pt_binstr).hex()

# ----------------------------------------------------------
# 【関数】CMACの生成。
# ----------------------------------------------------------
def cmac(msg, key):
    msg_binstr = binascii.unhexlify(msg)
    key_binstr = binascii.unhexlify(key)
    cobj = Crypto.Hash.CMAC.new(key_binstr, ciphermod = Crypto.Cipher.AES)
    cobj.update(msg_binstr)
    return cobj.hexdigest()

# ----------------------------------------------------------
# 【関数】鍵導出。
# ----------------------------------------------------------
def kdf(k, c):
    out0 = "00000000000000000000000000000000"
    out1 = format(int(enc_aes_ecb(k, out0), 16) ^ int(k, 16), '032x')
    out2 = format(int(enc_aes_ecb(c, out1), 16) ^ int(c, 16) ^ int(out1, 16), '032x')
    return out2

# ----------------------------------------------------------
# 【処理】K1を生成。
# ----------------------------------------------------------
k1 = kdf(key_authid, key_update_enc_c)

# ----------------------------------------------------------
# 【処理】K2を生成。
# ----------------------------------------------------------
k2 = kdf(key_authid, key_update_mac_c)

# ----------------------------------------------------------
# 【処理】M1を生成。
# ----------------------------------------------------------
m1 = uid + kid + authid

# ----------------------------------------------------------
# 【処理】M2を生成。
# ----------------------------------------------------------
m2_pt = c_id + format(int(f_id, 16) << 3, '02x') + "00000000000000000000000" + key_new
m2 = enc_aes_cbc(m2_pt, k1, "00000000000000000000000000000000")

# ----------------------------------------------------------
# 【処理】M3を生成。
# ----------------------------------------------------------
m3 = cmac(m1 + m2, k2)

# ----------------------------------------------------------
# 【処理】K3を生成。
# ----------------------------------------------------------
k3 = kdf(key_new, key_update_enc_c)

# ----------------------------------------------------------
# 【処理】K4を生成。
# ----------------------------------------------------------
k4 = kdf(key_new, key_update_mac_c)

# ----------------------------------------------------------
# 【処理】M4を生成。
# ----------------------------------------------------------
m4 = uid + kid + authid + enc_aes_ecb(c_id + "8000000000000000000000000", k3)

# ----------------------------------------------------------
# 【処理】M5を生成。
# ----------------------------------------------------------
m5 = cmac(m4, k4)

#print("K1 = " + k1)
#print("K2 = " + k2)
print("M1 = " + m1)
print("M2 = " + m2)
print("M3 = " + m3)
#print("K3 = " + k3)
#print("K4 = " + k4)
print("M4 = " + m4)
print("M5 = " + m5)
